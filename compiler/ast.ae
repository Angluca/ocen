use "lib/vector.ae"
use "lib/map.ae"
use "compiler/types.ae"
use "compiler/tokens.ae"
use "compiler/errors.ae"
use "compiler/scopes.ae"

enum ASTType {
    Block
    Call
    Error
    Identifier
    IntLiteral
    StringLiteral
    BoolLiteral
    Return
    NSLookup
    Import
    VarDeclaration
    If

    // Binary operators
    BitwiseAnd
    And
    BitwiseXor
    Equals
    Assignment
    GreaterThan
    GreaterThanEquals
    RightShift
    LessThan
    LessThanEquals
    LeftShift
    BitwiseOr
    Minus
    MinusEquals
    NotEquals
    Or
    Modulus
    Plus
    PlusEquals
    Divide
    DivideEquals
    Multiply
    MultiplyEquals
    BitwiseNot
}

def ASTType::from_token(type: TokenType): ASTType => match type {
    Ampersand => ASTType::BitwiseAnd
    And => ASTType::And
    Caret => ASTType::BitwiseXor
    EqualEquals => ASTType::Equals
    Equals => ASTType::Assignment
    GreaterThan => ASTType::GreaterThan
    GreaterThanEquals => ASTType::GreaterThanEquals
    GreaterThanGreaterThan => ASTType::RightShift
    LessThan => ASTType::LessThan
    LessThanEquals => ASTType::LessThanEquals
    LessThanLessThan => ASTType::LeftShift
    Line => ASTType::BitwiseOr
    Minus => ASTType::Minus
    MinusEquals => ASTType::MinusEquals
    NotEquals => ASTType::NotEquals
    Or => ASTType::Or
    Percent => ASTType::Modulus
    Plus => ASTType::Plus
    PlusEquals => ASTType::PlusEquals
    Slash => ASTType::Divide
    SlashEquals => ASTType::DivideEquals
    Star => ASTType::Multiply
    StarEquals => ASTType::MultiplyEquals
    Tilde => ASTType::BitwiseNot
    else => panic(`Unhandled token type in ASTType::from_token: {type.str()}`)
}

struct Variable {
    name: string
    type: &Type
    span: Span

    prefix: string

    // Only for functions, FIXMNE: move to `Parameter` type?
    default_value: &AST
}

def Variable::new(name: string, type: &Type, span: Span): &Variable {
    let var = calloc(1, sizeof(Variable)) as &Variable
    var.name = name
    var.type = type
    var.span = span
    var.prefix = ""
    return var
}

struct VarDeclaration {
    var: &Variable
    init: &AST
}

struct Function {
    name: string
    params: &Vector     // Vector<&Variable>
    return_type: &Type
    body: &AST
    exits: bool

    type: &Type
    span: Span
    prefix: string
}

def Function::new(span: Span): &Function {
    let func = calloc(1, sizeof(Function)) as &Function
    func.params = Vector::new()
    func.span = span
    return func
}

struct Program {
    global: &Namespace
    errors: &Vector       // Vector<&Error>
}

def Program::new(): &Program {
    let prog = calloc(1, sizeof(Program)) as &Program
    prog.global = Namespace::new(null, "", "")
    prog.errors = Vector::new()
    return prog
}

struct Block {
    statements: &Vector     // Vector<&AST>
    scope: &Scope
}

struct Identifier {
    name: string
    var: &Variable
    is_function: bool
    func: &Function
}

struct Argument {
    expr: &AST
    label: &AST // Identifier
}

def Argument::new(label: &AST, expr: &AST): &Argument {
    let arg = calloc(1, sizeof(Argument)) as &Argument
    arg.expr = expr
    arg.label = label
    return arg
}

struct FuncCall {
    callee: &AST
    args: &Vector    // Vector<&Argument>
    func: &Function
    is_function_pointer: bool
}

struct ImportPart {
    name: string
    span: Span
}

def ImportPart::new(name: string, span: Span): &ImportPart {
    let part = calloc(1, sizeof(ImportPart)) as &ImportPart
    part.name = name
    part.span = span
    return part
}

struct ImportPath {
    parts: &Vector    // &Vector<ImportPart>

    // For relative imports, we might have something like `import ..foo`, in which
    // case we need to know how namspace levels to go up.
    is_relative: bool
    parent_count: i32
}

struct NumLiteral {
    text: string
    suffix: &Type
}

struct Binary {
    lhs: &AST
    rhs: &AST
}

struct NSLookup {
    lhs: &AST
    rhs_name: string
    rhs_span: Span
}

struct IfStatement {
    cond: &AST
    body: &AST
    els: &AST
}

struct Loop {
    init: &AST
    cond: &AST
    incr: &AST
    body: &AST
}

struct Cast {
    lhs: &AST
    to: &Type
}

union ASTUnion {
    block: Block
    ident: Identifier
    call: FuncCall
    unary: &AST
    binary: Binary
    num_literal: NumLiteral
    string_literal: string
    bool_literal: bool
    lookup: NSLookup
    import_path: ImportPath
    var_decl: VarDeclaration
    if_stmt: IfStatement
    loop: Loop
    cast: Cast
}

struct AST {
    type: ASTType
    span: Span
    u: ASTUnion
    etype: &Type
    returns: bool
    resolved_symbol: &Symbol
}

def AST::new(type: ASTType, span: Span): &AST {
    let ast = calloc(1, sizeof(AST)) as &AST
    ast.type = type
    ast.span = span
    return ast
}

def AST::new_unop(type: ASTType, span: Span, expr: &AST): &AST {
    let ast = AST::new(type, span)
    ast.u.unary = expr
    return ast
}

def AST::new_binop(type: ASTType, lhs: &AST, rhs: &AST): &AST {
    let span = lhs.span.join(rhs.span)
    let ast = AST::new(type, span)
    ast.u.binary.lhs = lhs
    ast.u.binary.rhs = rhs
    return ast
}