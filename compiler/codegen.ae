use "lib/buffer.ae"
use "compiler/ast.ae"
use "compiler/utils.ae"

struct CodeGenerator {
    program: &Program
    out: Buffer
    indent: i32
}

def CodeGenerator::make(program: &Program): CodeGenerator {
    return CodeGenerator(
        program,
        out: Buffer::make(),
        indent: 0
    )
}

def CodeGenerator::error(&this, err: &Error) {
    .program.errors.push(err)
}

def CodeGenerator::gen_indent(&this) {
    for let i = 0; i < .indent; i += 1 {
        .out.puts("  ")
    }
}


def string::replace(&this, other: string) {
    let s: string = *this
    free(s)
    *this = other
}

def CodeGenerator::gen_expression(&this, node: &AST) {
    match node.type {
        IntLiteral => {
            let num_lit = &node.u.num_literal
            .out.puts(num_lit.text)
        }
        NSLookup => {
            let sym = node.u.lookup.resolved_symbol
            if not sym? {
                .error(Error::new(node.span, "Symbol not found"))
                return
            }
            match sym.type {
                Function => .out.puts(.get_function_name(sym.u.func))
                else => panic(`Unhandled symbol type: {sym.type}`)
            }
        }
        Call => {
            if node.u.call.is_function_pointer { 
                let callee = node.u.call.callee
                .gen_expression(callee)
            } else {
                .out.puts(.get_function_name(node.u.call.func))
            }
            // fixme: gen args
            .out.puts("()")
        }
        else => panic(`Unhandled expression type: {node.type}`)
    }
}

def CodeGenerator::gen_statement(&this, node: &AST) {
    match node.type {
        ASTType::Return => {
            .gen_indent()
            .out.puts("return ")
            .gen_expression(node.u.unary)
            .out.puts(";\n")
        }
        else => {
            .gen_indent()
            .gen_expression(node)
            .out.puts(";\n")
        }
    }
}

def CodeGenerator::gen_block(&this, node: &AST) {
    .out.puts("{\n")

    let statements = node.u.block.statements
    .indent += 1
    for let i = 0; i < statements.size; i += 1 {
        let statement = statements.at(i) as &AST
        .gen_statement(statement)
    }
    .indent -= 1
    .gen_indent()
    .out.puts("}")
}

def CodeGenerator::get_type_name_string(&this, type: &Type, name: string, is_func_def: bool): string {
    // This is a bit weird because of how C expects type names to be written.
    // There's possibly a better way to do this, but I'll leave that for another day.
    let final = name.copy()

    if not type? { panic("Internal error: null type in codegen") }

    for let cur = type; cur?; cur = cur.u.ptr {
        match cur.base {
            // These should all be terminal types
            Void | Bool | Char |
            I8   | I16  | I32  | I64 |
            U8   | U16  | U32  | U64 |
            F32  | F64 => final.replace(`{cur.base.str()} {final}`)

            Function => {
                let acc = Buffer::make()
                let params = cur.u.func.params

                if params.size == 0 then acc.puts("void")

                for let i = 0; i < params.size; i += 1 {
                    if i != 0 then acc.puts(", ")
                    let var = params.at(i) as &Variable
                    let arg_str = .get_type_name_string(var.type, var.name, is_func_def: false)
                    acc.putsf(arg_str)
                }
                if is_func_def and cur == type {
                    // This allows us to also create function declarations
                    final.replace(`{final}({acc.str()})`)
                } else {
                    final.replace(`(*{final})({acc.str()})`)
                }
                free(acc.data)
                final.replace(.get_type_name_string(
                    cur.u.func.return_type,
                    name: final,
                    is_func_def: false
                ))
            }
            Unresolved => {
                .error(Error::new(type.span, "Unresolved type found"))
            }
            Error => {
                .error(Error::new(type.span, "Error found in type"))
            }
            else => {
                .error(Error::new(type.span, `Unhandled type found: {type.str()}`))
            }
        }
    }
    final.strip_trailing_whitespace()
    return final
}

def CodeGenerator::gen_type_and_name(&this, type: &Type, name: string) {
    .out.putsf(.get_type_name_string(type, name, is_func_def: false))
}

def CodeGenerator::gen_type(&this, type: &Type) {
    .gen_type_and_name(type, name: "")
}

def CodeGenerator::get_function_name(&this, func: &Function): string {
    return `{func.prefix}{func.name}`
}

def CodeGenerator::gen_function(&this, func: &Function) {
    .gen_function_decl(func)
    .out.puts(" ")
    .gen_block(func.body)
    .out.puts("\n\n")
}

def CodeGenerator::gen_function_decl(&this, func: &Function) {
    let func_name = .get_function_name(func)
    let s = .get_type_name_string(func.type, func_name, true)
    .out.putsf(s)
}

def CodeGenerator::gen_functions(&this, ns: &Namespace) {
    let functions = ns.functions;
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .gen_function(func)
    }

    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        let child = iter.value() as &Namespace
        .gen_functions(child)
    }
}

def CodeGenerator::gen_function_decls(&this, ns: &Namespace) {
    let functions = ns.functions;
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .gen_function_decl(func)
        .out.puts(";\n")
    }

    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        let child = iter.value() as &Namespace
        .gen_function_decls(child)
    }
}


def CodeGenerator::generate(&this): string {
    .out.puts("#include <stdio.h>\n")
    .out.puts("#include <stdlib.h>\n")
    .out.puts("#include <stdint.h>\n")
    .out.puts("#include <stdbool.h>\n")

    .out.puts("typedef int32_t i32;\n")
    .out.puts("typedef int64_t i64;\n")
    .out.puts("typedef uint32_t u32;\n")
    .out.puts("typedef uint64_t u64;\n")
    .out.puts("typedef float f32;\n")
    .out.puts("typedef double f64;\n")
    // todo: gen structs / other stuff...

    .out.puts("/* function declarations */\n")
    .gen_function_decls(.program.global)

    .out.puts("/* function implementations */\n")
    .gen_functions(.program.global)

    return .out.str()
}
