use "compiler/ast.ae"
use "compiler/utils.ae"
use "lib/map.ae"

struct TypeChecker {
    cur_func: &Function
    program: &Program
    base_types_cache: [&Type; BaseType::NUM_BASE_TYPES as i32]
}

def TypeChecker::error(&this, err: &Error) {
    .program.errors.push(err)
}

def TypeChecker::new(program: &Program): &TypeChecker {
    let checker = calloc(1, sizeof(TypeChecker)) as &TypeChecker
    checker.program = program
    for let i = 0; i < BaseType::NUM_BASE_TYPES as i32; i += 1 {
        checker.base_types_cache[i] = Type::new(i as BaseType, Span::default())
    }
    return checker
}

def TypeChecker::get_type(&this, base: BaseType): &Type {
    return .base_types_cache[base as i32]
}

def TypeChecker::type_is_valid(&this, type: &Type): bool {
    if not type? return false

    match type.base {
        Pointer => return .type_is_valid(type.ptr)
        Function => {
            for let i = 0; i < type.func.params.size; i += 1 {
                let var = type.func.params.at(i) as &Variable
                if not .type_is_valid(var.type) {
                    return false
                }
            }
            return .type_is_valid(type.func.return_type)
        }
        Unresolved | Error => return false
        else => return true
    }
}

// def TypeChecker::check_call(&this, node: &AST): &Type {
//     // This is a hack to avoid typechecking of `print` and `println`
//     let callee = node.u.call.callee
//     if callee.type == ASTType::Identifier {
//         callee.u.ident.is_function = false
//         let name = callee.u.ident.name
//         if name.eq("print") or name.eq("println") {
//             for let i = 0; i < node.u.call.args.size; i += 1 {
//                 let arg = node.u.call.args.at(i) as &Argument
//                 .check_expression(arg.expr, hint: null)
//                 .call_dbg_on_enum_value(arg.expr)
//             }
//             return Type::new(BaseType::Void, node.span)
//         }

//         // If the name of the function is a Struct, then this is a constructor.
//         let struc = .structures.get(name) as &Structure
//         if struc? {
//             return .check_constructor(struc, node)
//         }
//     }

//     let func_type = .check_expression(callee, hint: null)
//     if not func_type? return null

//     let func_def = func_type.func_def
//     node.u.call.func = func_def

//     if func_def? and func_def.exits {
//         node.returns = true
//     }

//     if func_type.base != BaseType::Function and func_type.base != BaseType::Method {
//         .error(Error::new_note(
//             callee.span, "Cannot call a non-function type",
//             `Type for expression is '{func_type.str()}'`
//         ))
//         return null
//     }

//     if func_type.base == BaseType::Method {
//         .check_method_call(func_type, node)
//     }

//     let params = func_type.params
//     if params.size != node.u.call.args.size {
//         .error(Error::new_hint(
//             node.span, "Number of arguments does not match function signature",
//             func_type.span, `This function expects {params.size} arguments, got {node.u.call.args.size}`
//         ))
//         return func_type.return_type
//     }

//     for let i = 0; i < params.size; i += 1 {
//         let param = params.at(i) as &Variable
//         let arg = node.u.call.args.at(i) as &Argument
//         let arg_type = .check_expression(arg.expr, hint: param.type)
//         if arg_type? and not param.type.eq(arg_type) {
//             .error(Error::new_hint(
//                 arg.expr.span, "Argument type does not match function parameter type",
//                 param.span, `Expected '{param.type.str()}', got '{arg_type.str()}'`
//             ))
//         }

//         if not arg.label? continue
//         if param.name.eq("") {
//             .error(Error::new_hint(
//                 arg.label.span, "Label on non-labeled parameter",
//                 param.span, "This parameter does not have a name"
//             ))
//         }
//         let label = arg.label.u.ident.name
//         if not label.eq(param.name) {
//             .error(Error::new_hint(
//                 arg.label.span, "Label on parameter does not match parameter name",
//                 param.span, `Expected '{param.name}', got '{label}'`
//             ))
//         }
//     }

//     return func_type.return_type
// }

// def TypeChecker::check_expression(&this, node: &AST, hint: &Type): &Type {
//     let etype = null as &Type
//     match node.type {
//         Call            => etype = .check_call(node)
//         IntLiteral => {
//             let num_lit = &node.u.num_literal
//             if num_lit.suffix? {
//                 etype = num_lit.suffix
//                 if not .type_is_valid(etype) {
//                     .error(Error::new(etype.span, "Invalid type"))
//                 }
//             } else if node.type == ASTType::IntLiteral {
//                 etype = if hint? and hint.is_integer() {
//                     yield hint
//                 } else {
//                     yield Type::new(BaseType::I32, node.span)
//                 }
//             } else {
//                 etype = if hint? and hint.is_float() {
//                     yield hint
//                 } else {
//                     yield Type::new(BaseType::F32, node.span)
//                 }
//             }
//         }
//         Identifier => {
//             let ident = &node.u.ident
//             let var = .find_var(ident.name)
//             let func = .functions.get(ident.name) as &Function

//             if hint? and .try_infer_enum(node, type: hint) {
//                 etype = node.etype
//             } else if ident.is_function {
//                 etype = ident.func.type
//             } else if var? {
//                 ident.is_function = false
//                 ident.var = var
//                 etype = var.type
//             } else if func? {
//                 ident.is_function = true
//                 ident.func = func
//                 etype = func.type
//             } else {
//                 .error_unknown_identifier(node.span, ident.name)
//                 return null
//             }
//         }
//         ScopeLookup => {
//             if node.u.member.lhs.type != ASTType::Identifier {
//                 .error(Error::new(node.u.member.lhs.span, "Left hand side of `::` must be a struct name"))
//                 return null
//             }

//             let struct_name = node.u.member.lhs.u.ident.name
//             let struc = .structures.get(struct_name) as &Structure
//             if not struc? {
//                 .error(Error::new(node.u.member.lhs.span, "Unknown struct with this name"))
//                 return null
//             }

//             let lhs = node.u.member.lhs
//             lhs.etype = struc.type

//             let rhs = node.u.member.rhs
//             let field_name = rhs.u.ident.name
//             let var = .get_struct_member(struct_name, field_name)

//             let s_methods = .methods.get(struct_name) as &Map
//             let method = s_methods.get(field_name) as &Function
//             if struc.is_enum and var? {
//                 rhs.u.ident.var = var
//                 // FIXME: This is a hack, we're modifying the AST Node type
//                 // This is an enum value
//                 node.type = ASTType::EnumValue
//                 node.u.enum_val.struct_def = struc
//                 node.u.enum_val.var = var
//                 node.u.enum_val.lhs = lhs
//                 node.u.enum_val.rhs = rhs
//                 etype = struc.type

//             } else if method? {
//                 rhs.u.ident.is_function = true
//                 rhs.u.ident.func = method
//                 etype = method.type
//             } else {
//                 .error_unknown_member(node, struc.type, field_name, is_static: true)
//                 return null
//             }
//         }
//         else => .error(Error::new(node.span, "Expected an expression statement"))
//     }
//     if not etype? return null
//     etype = etype.decay_array()
//     node.etype = etype
//     return etype
// }

// def TypeChecker::check_statement(&this, node: &AST) {
//     match node.type {
//         ASTType::Block => .check_block(node, can_yield: false)
//         ASTType::Return => {
//             if not .cur_func? {
//                 .error(Error::new(node.span, "Return statement outside of function"))
//             }
//             if not node.u.unary? {
//                 if .cur_func.return_type.base != BaseType::Void {
//                     .error(Error::new_hint(
//                         node.span, "Cannot have empty return in non-void function",
//                         .cur_func.return_type.span, `This function returns '{.cur_func.return_type.str()}'`
//                     ))
//                 }
//             } else {
//                 let ret_type = .check_expression(node.u.unary, hint: .cur_func.return_type)
//                 if ret_type? and .cur_func.return_type.base == BaseType::Void {
//                     // Allow using arrow syntax for one-line void functions
//                     if ret_type.base != BaseType::Void {
//                         .error(Error::new_hint(
//                             node.u.unary.span, `Cannot return '{ret_type.str()}' in void function`,
//                             .cur_func.span, "This function does not return a value"
//                         ))
//                     }
//                 }
//                 if ret_type? and not ret_type.eq(.cur_func.return_type) {
//                     .error(Error::new_hint(
//                         node.u.unary.span, `Return type '{ret_type.str()}' is incorrect`,
//                         .cur_func.return_type.span, `This function returns '{.cur_func.return_type.str()}'`
//                     ))
//                 }
//             }
//             node.returns = true
//         }
//         else => .check_expression(node, hint: null)
//     }
// }

// def TypeChecker::check_block(&this, node: &AST, can_yield: bool) {
//     let could_yield = .can_yield
//     .can_yield = can_yield

//     let yield_span: Span

//     .push_scope()
//     let statements = node.u.block.statements
//     for let i = 0; i < statements.size; i += 1 {
//         let statement = statements.at(i) as &AST
//         .check_statement(statement)
//         if statement.returns {
//             node.returns = true
//         }
//         if statement.type != ASTType::Yield continue
//         if node.etype? {
//             .error(Error::new_hint(
//                 statement.span, "Cannot yield multiple times in a block",
//                 yield_span, "Previously yield here is here"
//             ))
//         }
//         node.etype = statement.etype
//         yield_span = statement.span
//     }

//     .pop_scope()
//     .can_yield = could_yield
// }

// def TypeChecker::check_function(&this, func: &Function) {
//     let prev_func = .cur_func
//     .cur_func = func
//     .push_scope()

//     // The types of parameters and return are checked in decl-pass
//     for let i = 0; i < func.params.size; i += 1 {
//         let var = func.params.at(i) as &Variable
//         .push_var(var)
//     }

//     if func.body? {
//         if func.is_arrow {
//             .check_statement(func.body)
//         } else {
//             .check_block(func.body, can_yield: false)
//         }
//         if not func.body.returns and func.return_type.base != BaseType::Void {
//             if not func.name.eq("main") {
//                 .error(Error::new(func.span, "Function does not always return"))
//             }
//         }
//     }

//     .pop_scope()
//     .cur_func = prev_func
// }

// def TypeChecker::check_all_functions(&this, program: &Program) {
//     for let i = 0; i < program.functions.size; i += 1 {
//         let func = program.functions.at(i) as &Function
//         let name        = func.name
//         let struct_name = func.method_struct_name
//         let func_type = null as &Type

//         if func.is_method {
//             let s_methods = .methods.get(struct_name) as &Map
//             if not s_methods? {
//                 .error(Error::new(func.span, "Type for method does not exist"))
//             }
//             if s_methods? and s_methods.exists(name) {
//                 let method = s_methods.get(name) as &Function
//                 .error(Error::new_hint(
//                     func.span, "Method is already defined for this type",
//                     method.span, "Previous definition here"
//                 ))
//             }
//             let var = .get_struct_member(struct_name, name)
//             if var? {
//                 .error(Error::new_hint(
//                     func.span, "Type already has a field with this name",
//                     var.span, "Previous definition here"
//                 ))
//             }

//             func_type = Type::new(BaseType::Method, func.span)
//             func_type.name = struct_name
//         } else {
//             func_type = Type::new(BaseType::Function, func.span)

//             if .functions.exists(name) {
//                 let prev = .functions.get(name) as &Function
//                 .error(Error::new_hint(
//                     func.span, "Function is already defined",
//                     prev.span, "Previous definition here"
//                 ))
//             }
//         }
//         func_type.func_def = func

//         for let j = 0; j < func.params.size; j += 1 {
//             let param = func.params.at(j) as &Variable
//             if not .type_is_valid(param.type) {
//                 .error(Error::new(param.type.span, "Invalid parameter type"))
//             }
//         }
//         func_type.params = func.params

//         if not .type_is_valid(func.return_type) {
//             .error(Error::new(func.return_type.span, "Invalid return type"))
//         }
//         func_type.return_type = func.return_type
//         func.type             = func_type

//         if func.is_method {
//             let s_methods = .methods.get(struct_name) as &Map
//             if s_methods? then s_methods.insert(name, func)
//         } else {
//             .functions.insert(name, func)
//         }
//     }

//     for let i = 0; i < program.functions.size; i += 1 {
//         .check_function(program.functions.at(i) as &Function)
//     }
// }

def TypeChecker::pre_check_namespace_function(&this, ns: &Namespace, func: &Function) {
    // todo: check if exists, check types
    let item = NamedItem::from_function(func.name, func)
    ns.scope.items.insert(func.name, item)
    println(`inserted function {ns.prefix}{func.name} into scope`)
}

def TypeChecker::pre_check_namespace(&this, ns: &Namespace) {
    let functions = ns.functions;
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .pre_check_namespace_function(ns, func)
    }
    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        println(`recursing on namespace {iter.key()}`)
        .pre_check_namespace(iter.value())
    }
}

def TypeChecker::check_block(&this, node: &AST, scope: &Scope) {
    let block = node.u.block
    block.scope = Scope::new(scope)
    let stmts = block.statements
    for let i = 0; i < stmts.size; i += 1 {
        let stmt = stmts.at(i) as &AST
        .check_statement(stmt, block.scope)
    }
}

def TypeChecker::resolve_scope_lookup(&this, node: &AST, scope: &Scope): &NamedItem {
    match node.type {
        ASTType::ScopeLookup => {
            let lhs = .resolve_scope_lookup(node.u.binary.lhs, scope)
            if not lhs? {
                .error(Error::new(node.u.binary.lhs.span, "couldn't resolve scope lookup lhs"))
                return null
            }

            if lhs.type != NamedItemType::Namespace {
                .error(Error::new(node.u.binary.lhs.span, "needs to be a namespace to lookup"))
                return null
            }

            let rhs = node.u.binary.rhs
            if rhs.type != ASTType::Identifier {
                .error(Error::new(rhs.span, "Needs to be an identifier..."))
                return null
            }

            let ns_scope = lhs.u.ns.scope
            let name = rhs.u.ident.name
            return ns_scope.lookup_recursive(name)
        }
        ASTType::Identifier => {
            let name = node.u.ident.name
            return scope.lookup_recursive(name)
        }
        else => {
            .error(Error::new(node.span, "Invalid scope lookup node"))
            return null
        }
    }
}

def TypeChecker::check_expression(&this, node: &AST, scope: &Scope): &Type {
    match node.type {
        ASTType::IntLiteral => {
            println(`int literal with value {node.u.num_literal.text}`)
            return .get_type(BaseType::I32)
        }
        ASTType::Identifier | ASTType::ScopeLookup => {
            let item = .resolve_scope_lookup(node, scope)
            return null
        }
        ASTType::Call => {
            // fixme: so much to check... args, existing function, etc...
            let callee = node.u.call.callee
            let item = .resolve_scope_lookup(callee, scope)
            if item? {
                println(`call to {item.name}!!`)
                if item.type == NamedItemType::Function {
                    println(`got a function {item.name}!!`)
                    node.u.call.is_function_pointer = false
                } else {
                    // check if function pointer (var of type function)
                    .error(Error::new(callee.span, "Not a function"))
                }
            } else {
                .error(Error::new(callee.span, "Unknown function"))
            }
            return null
        }
        else => {
            .error(Error::new(node.span, "Invalid expression lol"))
            return null
        }
    }
}

def TypeChecker::check_statement(&this, node: &AST, scope: &Scope) {
    match node.type {
        ASTType::Return => {
            // todo: make sure in function
            // todo: empty return
            // todo: actually check return type
            let res = .check_expression(node.u.unary, scope)
            if res? {
                println(`return statement with type {res.str()}`)
            }
        }
        else => {
            .error(Error::new(node.span, "Invalid statement lol"))
            return
        }
    }
}

def TypeChecker::check_namespace_function(&this, ns: &Namespace, func: &Function) {
    // todo: check params, return type
    // todo: new scope for func args
    .check_block(func.body, ns.scope)
}

def TypeChecker::check_namespace(&this, ns: &Namespace) {
    let functions = ns.functions;
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .check_namespace_function(ns, func)
    }
    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        // check if exists
        let name = iter.key()
        // TODO: actually check the imports for the module and only add those ones to the ns
        let item = NamedItem::from_namespace(name, iter.value())
        ns.scope.items.insert(name, item)
        .check_namespace(iter.value())
    }
}

def TypeChecker::check(&this) {
    let global_ns = .program.global
    .pre_check_namespace(global_ns)
    .check_namespace(global_ns)
}
