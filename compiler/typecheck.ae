use "compiler/ast.ae"
use "compiler/utils.ae"
use "lib/map.ae"

struct TypeChecker {
    cur_func: &Function
    program: &Program
    error_type: &Type
}

def TypeChecker::error(&this, err: &Error): &Error {
    .program.errors.push(err)
    return err
}

def TypeChecker::init_base_type(&this, base: BaseType) {
    let name = base.str()
    let sym = Symbol::from_type(name, Type::new_resolved(base, Span::default()))
    .program.global.scope.items.insert(name, sym)
}

def TypeChecker::init_builtin_types(&this) {
    for let i = 0; i < BaseType::NUM_BASE_TYPES as i32; i += 1 {
        .init_base_type(i as BaseType)
    }
    .error_type = Type::new_resolved(BaseType::Error, Span::default())
}

def TypeChecker::get_base_type(&this, base: BaseType, span: Span): &Type {
    let sym = .program.global.scope.lookup_local(base.str())
    if sym? and sym.type == SymbolType::TypeDef {
        return sym.u.type_def
    } else {
        .error(Error::new(Span::default(), "Internal compiler error, couldn't find base type"))
        return .error_type
    }
}

def TypeChecker::new(program: &Program): &TypeChecker {
    let checker = calloc(1, sizeof(TypeChecker)) as &TypeChecker
    checker.program = program
    checker.init_builtin_types()
    return checker
}

def TypeChecker::resolve_type(&this, old: &Type, scope: &Scope): &Type {
    let resolved = old
    match old.base {
        // Otherwise...
        Pointer => {
            resolved.u.ptr = .resolve_type(old.u.ptr, scope)
        }
        Function => {
            let func = old.u.func
            for let i = 0; i < func.params.size; i += 1 {
                let var = func.params.at(i) as &Variable
                var.type = .resolve_type(var.type, scope)
            }
            func.return_type = .resolve_type(func.return_type, scope)
        }
        Unresolved => {
            let res = scope.lookup_recursive(old.name)
            if res? {
                match res.type {
                    SymbolType::TypeDef => resolved = res.u.type_def
                    SymbolType::Structure => resolved = res.u.struc.type
                    else => {
                        .error(Error::new(old.span, "Could not resolve type"))
                        resolved = .error_type
                    }
                }
            } else {
                .error(Error::new(old.span, "Could not resolve type"))
                resolved = .error_type
            }
        }
        else => {
            .error(Error::new(old.span, `Unhandled type in resolve {old.base}`))
            resolved = .error_type
        }
    }
    return resolved
}

def TypeChecker::check_block(&this, node: &AST, scope: &Scope) {
    let block = node.u.block
    block.scope = Scope::new(scope)
    let stmts = block.statements
    for let i = 0; i < stmts.size; i += 1 {
        let stmt = stmts.at(i) as &AST
        .check_statement(stmt, block.scope)
    }
}

def TypeChecker::resolve_scope_lookup(&this, node: &AST, scope: &Scope): &Symbol {
    match node.type {
        ASTType::NSLookup => {
            // FIXME: this is all sorts of hacky
            let lhs = .resolve_scope_lookup(node.u.lookup.lhs, scope)
            if not lhs? {
                .error(Error::new(node.u.lookup.lhs.span, "couldn't resolve scope lookup lhs"))
                return null
            }

            if lhs.type != SymbolType::Namespace {
                .error(Error::new(node.u.lookup.lhs.span, "needs to be a namespace to lookup"))
                return null
            }
            let ns = lhs.u.ns

            let name = node.u.lookup.rhs_name
            let res = ns.find_importable_symbol(name)
            node.resolved_symbol = res
            return res
        }
        ASTType::Identifier => {
            let name = node.u.ident.name
            let res = scope.lookup_recursive(name)
            node.resolved_symbol = res
            return res
        }
        else => {
            .error(Error::new(node.span, "Invalid scope lookup node"))
            return null
        }
    }
}

def TypeChecker::check_call(&this, node: &AST, scope: &Scope): &Type {
    // fixme: so much to check... args, existing function, etc...
    let callee = node.u.call.callee
    let args = node.u.call.args

    // FIXME: this is a fucking abonimation
    if callee.type == ASTType::Identifier {
        callee.u.ident.is_function = false
        let name = callee.u.ident.name

        if name.eq("print") or name.eq("println") {
            for let i = 0; i < args.size; i += 1 {
                let arg = args.at(i) as &Argument
                .check_expression(arg.expr, scope)
            }
            return .get_base_type(Void, node.span)
        }
    }

    // FIXME: we want to be able to call `resolve_scope_lookup` here, but we can't because
    // we also want to be able to do something like `foo.bar()` etc where the LHS is not a scope lookup
    let res = .check_expression(callee, scope)
    if res? and res.base == BaseType::Function {
        let func = res.u.func
        let params = func.params

        if func.params.size < args.size {
            .error(Error::new(node.span, `Too many arguments, expected {func.params.size} but got {args.size}`))
        }

        for let i = 0; i < params.size; i += 1 {
            let param = params.at(i) as &Variable
            // Normal case
            if i < args.size {
                let arg = args.at(i) as &Argument
                let arg_type = .check_expression(arg.expr, scope)
                if arg_type? and not arg_type.eq(param.type) {
                    .error(Error::new(arg.expr.span, `Argument {i} has type {arg_type.str()} but expected {param.type.str()}`))
                }

            // Default argument case
            } else if param.default_value? {

                // FIXME: We should not be evaluating the default argument here during every call, 
                // we should be evaluating it at the time of checking the function declaration and using
                // a cached value here
                let new_arg = Argument::new(label: null, expr: param.default_value)
                // Plus the default argument to the list of arguments
                args.push(new_arg)
            } else {
                .error(Error::new(node.span, `Missing required argument {param.name}`))
            }
        }

        if func.orig? {
            node.u.call.is_function_pointer = false
            node.u.call.func = func.orig
        }

        return func.return_type
    } else {
        .error(Error::new(callee.span, "Cannot call this expression"))
        return .error_type
    }
}

def TypeChecker::check_pointer_arith(&this, node: &AST, _lhs: &Type, _rhs: &Type): &Type {
    .error(Error::new(node.span, "Pointer arithmetic not implemented"))
    return null
}

def TypeChecker::check_binary_op(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {
    match node.type {
        Plus | Minus | Multiply | Divide => {
            if lhs.base == BaseType::Pointer or rhs.base == BaseType::Pointer {
                return .check_pointer_arith(node, lhs, rhs)
            } else if not lhs.is_numeric() or not rhs.is_numeric() {
                .error(Error::new_note(
                    node.span, "Operator requires numeric types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            } else if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
                return null
            } else {
                return lhs
            }
        }
        LessThan | LessThanEquals | GreaterThan | GreaterThanEquals => {
            if not lhs.is_numeric_or_char() or not rhs.is_numeric_or_char() {
                .error(Error::new_note(
                    node.span, "Operator requires numeric or char types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            return .get_base_type(BaseType::Bool, node.span)
        }
        Equals | NotEquals => {
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            // if lhs.base == BaseType::Structure {
            //     let struc = .structures.get(lhs.name) as &Structure
            //     if not struc.is_enum {
            //         .error(Error::new(node.span, "Cannot compare structs directly"))
            //     }
            // }
            return .get_base_type(BaseType::Bool, node.span)
        }
        And | Or => {
            if not lhs.eq(rhs) or lhs.base != BaseType::Bool {
                .error(Error::new_note(
                    node.span, "Operands must be boolean",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            return .get_base_type(BaseType::Bool, node.span)
        }
        Modulus | BitwiseOr | BitwiseAnd | BitwiseXor | LeftShift | RightShift => {
            if not lhs.is_integer() or not rhs.is_integer() {
                .error(Error::new_note(
                    node.span, "Operator requires integer types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                ))
            }
            return lhs
        }
        else => panic(`Internal error: unhandled op in check_binary_op: {node.type}`)
    }
}

def TypeChecker::check_expression(&this, node: &AST, scope: &Scope): &Type {
    match node.type {
        ASTType::IntLiteral => {
            return .get_base_type(BaseType::I32, node.span)
        }
        ASTType::StringLiteral => {
            // FIXME: make string a "base" type so we can attach methods to it
            let base = .get_base_type(BaseType::Char, node.span)
            let typ = Type::new_resolved(BaseType::Pointer, node.span)
            typ.u.ptr = base
            return typ
        }
        ASTType::CharLiteral => {
            return .get_base_type(BaseType::Char, node.span)
        }
        ASTType::BoolLiteral => {
            return .get_base_type(BaseType::Bool, node.span)
        }
        ASTType::Address => {
            let typ = .check_expression(node.u.unary, scope)
            if not typ? return null
            let ptr = Type::new_resolved(BaseType::Pointer, node.span)
            ptr.u.ptr = typ
            return ptr
        }
        ASTType::Dereference => {
            let typ = .check_expression(node.u.unary, scope)
            if not typ? return null
            if typ.base != BaseType::Pointer {
                .error(Error::new(node.span, `Cannot dereference non-pointer type: {typ.str()}`))
                return null
            }
            return typ.u.ptr
        }
        ASTType::Member => {
            let lhs = .check_expression(node.u.member.lhs, scope)
            if not lhs? return null

            let is_pointer = false
            if lhs.base == BaseType::Pointer {
                is_pointer = true
                lhs = lhs.u.ptr
            }

            if lhs.base != BaseType::Structure {
                .error(Error::new(node.span, "Can only access members of (pointers to) structs"))
                return null
            }

            let struc = lhs.u.struc
            let field = struc.get_field(node.u.member.rhs_name)
            if not field? {
                .error(Error::new(node.span, `Struct has no field named '{node.u.member.rhs_name}'`))
                return null
            }
            node.u.member.is_pointer = is_pointer
            return field.type
        }
        ASTType::Identifier | ASTType::NSLookup => {
            let item = .resolve_scope_lookup(node, scope)
            if not item? {
                .error(Error::new(node.span, "Couldn't resolve this expression"))
                return null
            }

            match item.type {
                Function => return item.u.func.type
                Variable => return item.u.var.type
                Structure => {
                    .error(Error::new(node.span, "Cannot use a struct name as an expression"))
                    return null
                }
                Namespace => {
                    .error(Error::new(node.span, "Cannot use a namespace as an expression"))
                    return null
                }
                TypeDef => {
                    // Fixme: How will this work with struct constructors?
                    .error(Error::new(node.span, "Cannot use a type name as an expression"))
                    return null
                }
            }
        }
        ASTType::Call => return .check_call(node, scope)

        // Binary operators
        Plus |
        Minus |
        Multiply |
        Divide |
        LessThan |
        LessThanEquals |
        GreaterThan |
        GreaterThanEquals |
        Equals |
        NotEquals |
        And |
        Or |
        Modulus |
        BitwiseOr |
        BitwiseAnd |
        BitwiseXor |
        LeftShift |
        RightShift => {
            let lhs = .check_expression(node.u.binary.lhs, scope)
            let rhs = .check_expression(node.u.binary.rhs, scope)
            if not lhs? or not rhs? return null
            return .check_binary_op(node, lhs, rhs)
        }

        Assignment => {
            let lhs = .check_expression(node.u.binary.lhs, scope)
            let rhs = .check_expression(node.u.binary.rhs, scope)
            if not lhs? or not rhs? return null

            if not node.u.binary.lhs.is_lvalue() {
                .error(Error::new(node.u.binary.lhs.span, "Must be an l-value"))
            }
            if not lhs.eq(rhs) {
                .error(Error::new_note(
                    node.span, "Variable type does not match assignment type",
                    `Expected type '{lhs.str()}', got '{rhs.str()}'`
                ))
            }
            return lhs
        }

        else => {
            .error(Error::new(node.span, "Invalid expression in TypeChecker::check_expression"))
            return .error_type
        }
    }
}

def TypeChecker::check_if(&this, node: &AST, scope: &Scope) {
    let cond_type = .check_expression(node.u.if_stmt.cond, scope)
    if cond_type? and cond_type.base != BaseType::Bool {
        .error(Error::new_note(
            node.u.if_stmt.cond.span, "Condition must be a boolean",
            `Got type '{cond_type.str()}'`
        ))
    }
    .check_statement(node.u.if_stmt.body, scope)
    if node.u.if_stmt.els? {
        let else_stmt = node.u.if_stmt.els
        .check_statement(else_stmt, scope)

    }
}

def TypeChecker::check_while(&this, node: &AST, scope: &Scope) {
    let cond = node.u.loop.cond
    let body = node.u.loop.body

    let cond_type = .check_expression(cond, scope)
    if cond_type? and cond_type.base != BaseType::Bool {
        .error(Error::new_note(
            node.u.if_stmt.cond.span, "Condition must be a boolean",
            `Got type '{cond_type.str()}'`
        ))
    }
    .check_statement(body, scope)
}

def TypeChecker::check_statement(&this, node: &AST, scope: &Scope) {
    match node.type {
        ASTType::Return => {
            // todo: make sure in function
            if not .cur_func? {
                .error(Error::new(node.span, "Cannot return from outside a function"))
                return
            }

            let expected = .cur_func.return_type
            if expected.base == BaseType::Void {
                if node.u.unary? {
                    .error(Error::new(node.span, "Cannot return a value from a void function"))
                }
            } else if node.u.unary? {
                let res = .check_expression(node.u.unary, scope)
                if res? and not res.eq(expected) {
                    .error(Error::new(node.span, `Return type {res.str()} does not match function return type {expected.str()}`))
                }
            } else {
                .error(Error::new(node.span, "Expected a return value for non-void function"))
            }

        }
        ASTType::If => .check_if(node, scope)
        ASTType::While => .check_while(node, scope)
        ASTType::Block => .check_block(node, scope)
        ASTType::VarDeclaration => {
            // FIXME: check if it exists in the scope already
            let var = node.u.var_decl.var
            let res = scope.lookup_local(var.name)
            if res? {
                .error(Error::new(node.span, `Variable {var.name} already exists in this scope`))
                return
            }

            let sym = Symbol::from_variable(var)
            scope.items.insert(var.name, sym)

            if var.type? {
                var.type = .resolve_type(var.type, scope)
            }

            let init = node.u.var_decl.init
            if init? {
                let res = .check_expression(init, scope)
                if res? and var.type? and not res.eq(var.type) {
                    .error(Error::new(init.span, `Variable {var.name} has type {var.type.str()} but initializer has type {res.str()}`))
                } else if not var.type? {
                    var.type = res
                }
            } else if not var.type? {
                .error(Error::new(node.span, `Variable {var.name} has no type and no initializer`))
            }
        }
        else => .check_expression(node, scope)
    }
}

def TypeChecker::check_function(&this, ns: &Namespace, func: &Function) {
    // todo: check params, return type
    let new_scope = Scope::new(ns.scope)

    let params = func.params
    for let i = 0; i < params.size; i += 1 {
        let param = params.at(i) as &Variable

        let default_expr = param.default_value
        if default_expr? {
            let default_type = .check_expression(default_expr, ns.scope)
            if not default_type? {
                .error(Error::new(default_expr.span, "Couldn't resolve default argument expression"))
            } else if not default_type.eq(param.type) {
                .error(Error::new(default_expr.span, `Default argument has type {default_type.str()} but expected {param.type.str()}`))
            }
        }

        new_scope.items.insert(param.name, Symbol::from_variable(param))
    }

    func.prefix = ns.prefix
    .cur_func = func
    .check_block(func.body, new_scope)
}

def TypeChecker::check_struct(&this, ns: &Namespace, struc: &Structure) {
    let fields = struc.fields
    struc.prefix = ns.prefix
    for let i = 0; i < fields.size; i += 1 {
        let field = fields.at(i) as &Variable
        let res = .resolve_type(field.type, ns.scope)
        if not res? {
            .error(Error::new(field.span, "Couldn't resolve type"))
        } else {
            field.type = res
        }
    }
}

def TypeChecker::check_namespace(&this, ns: &Namespace) {
    let imports = ns.imports
    for let i = 0; i < imports.size; i += 1 {
        let import = imports.at(i) as &AST
        .handle_import_statement(import, ns, ns.scope)
    }

    // FIXME: We need to do a topological sort here to make sure we don't
    // try to use a type before it's defined. For now they are being defined
    // in the order some indeterminate hash map iterator returns them in.
    let structs = ns.structs
    for let i = 0; i < structs.size; i += 1 {
        let struc = structs.at(i) as &Structure
        .check_struct(ns, struc)
    }

    let functions = ns.functions;
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .check_function(ns, func)
    }

    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        // check if exists
        let name = iter.key()
        .check_namespace(iter.value())
    }
}

// Insert all the imported items defined in the Import AST statement, (relative to the current namespace),
// into the current scope.
def TypeChecker::handle_import_statement(&this, node: &AST, ns: &Namespace, scope: &Scope) {
    let path = node.u.import_path

    let base = .program.global
    if path.is_relative {
        base = ns
        for let i = 0; i < path.parent_count; i += 1 {
            if not base.parent? {
                // This should never happen, because the parser is responsible for handling this
                .error(Error::new(node.span, "Internal error: Could not typecheck import statement"))
                return
            }
            base = base.parent
        }
    }

    for let i = 0; i < path.parts.size-1; i += 1 {
        let part = path.parts.at(i) as &ImportPart
        let name = part.name
        let new_ns = base.namespaces.get(name)

        if not new_ns? {
            .error(Error::new(part.span, `Invalid import, namespace {name} does not exist`))
            return
        }
        base = new_ns
    }

    let last_part = path.parts.back() as &ImportPart
    let name = last_part.name
    let sym = base.find_importable_symbol(name)
    if not sym? {
        .error(Error::new(node.span, `Couldn't find importable symbol {name}`))
        return
    }
    println(`imported symbol {name} with type {sym.type} into namespace {ns.prefix}`)
    scope.items.insert(name, sym)

}

////// Pre-checking namespace for declarations //////

def TypeChecker::pre_check_function(&this, ns: &Namespace, func: &Function) {
    let item = Symbol::from_function(func.name, func)
    // FIXME: check if name already exists in scope
    ns.scope.items.insert(func.name, item)

    func.return_type = .resolve_type(func.return_type, ns.scope)
    let params = func.params
    for let i = 0; i < params.size; i += 1 {
        let param = params.at(i) as &Variable
        param.type = .resolve_type(param.type, ns.scope)
    }

    // A function keeps track of a type that represents an equivalent function pointer type
    // This is used for type checking function calls
    let typ = Type::new_resolved(Function, func.span)
    typ.u.func = FunctionType::from_func(func)
    func.type = typ
}

def TypeChecker::pre_check_struct(&this, ns: &Namespace, struc: &Structure) {
    let item = Symbol::from_structure(struc)
    // FIXME: check if name already exists in scope
    ns.scope.items.insert(struc.name, item)

    let typ = Type::new_resolved(Structure, struc.span)
    typ.u.struc = struc
    struc.type = typ
    // FIXME: Where do we create the Type for this struct?
}

def TypeChecker::pre_check_namespace(&this, ns: &Namespace) {
    let structs = ns.structs
    for let i = 0; i < structs.size; i += 1 {
        let struc = structs.at(i) as &Structure
        .pre_check_struct(ns, struc)
    }

    let functions = ns.functions
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .pre_check_function(ns, func)
    }

    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        let child = iter.value() as &Namespace
        let name = iter.key()

        if child.is_user_defined {
            ns.scope.items.insert(name, Symbol::from_namespace(name, child))
        }
        .pre_check_namespace(iter.value())
    }
}

////// Top-level call program //////

def TypeChecker::check(&this) {
    let global_ns = .program.global
    .pre_check_namespace(global_ns)
    .check_namespace(global_ns)
}
