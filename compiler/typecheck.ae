use "compiler/ast.ae"
use "compiler/utils.ae"
use "lib/map.ae"

struct TypeChecker {
    cur_func: &Function
    program: &Program
    error_type: &Type
}

def TypeChecker::error(&this, err: &Error): &Error {
    .program.errors.push(err)
    return err
}

def TypeChecker::init_base_type(&this, base: BaseType) {
    let name = base.str()
    let sym = Symbol::from_type(name, Type::new_resolved(base, Span::default()))
    .program.global.scope.items.insert(name, sym)
}

def TypeChecker::init_builtin_types(&this) {
    for let i = 0; i < BaseType::NUM_BASE_TYPES as i32; i += 1 {
        .init_base_type(i as BaseType)
    }
    .error_type = Type::new_resolved(BaseType::Error, Span::default())
}

def TypeChecker::get_base_type(&this, base: BaseType, span: Span): &Type {
    let sym = .program.global.scope.lookup_local(base.str())
    if sym? and sym.type == SymbolType::TypeDef {
        return sym.u.type_def
    } else {
        .error(Error::new(Span::default(), "Internal compiler error, couldn't find base type"))
        return .error_type
    }
}

def TypeChecker::new(program: &Program): &TypeChecker {
    let checker = calloc(1, sizeof(TypeChecker)) as &TypeChecker
    checker.program = program
    checker.init_builtin_types()
    return checker
}

def TypeChecker::resolve_type(&this, old: &Type, scope: &Scope): &Type {
    let resolved = old
    match old.base {
        // Otherwise...
        Pointer => resolved.u.ptr = .resolve_type(old.u.ptr, scope)
        Function => {
            let func = old.u.func
            for let i = 0; i < func.params.size; i += 1 {
                let var = func.params.at(i) as &Variable
                var.type = .resolve_type(var.type, scope)
            }
            func.return_type = .resolve_type(func.return_type, scope)
        }
        Unresolved => {
            let res = scope.lookup_recursive(old.name)
            if res? and res.type == SymbolType::TypeDef {
                resolved = res.u.type_def
            } else {
                .error(Error::new(old.span, "Could not resolve resolve type"))
                resolved = .error_type
            }
        }
        else => {
            .error(Error::new(old.span, `Unhandled type in resolve {old.base}`))
            resolved = .error_type
        }
    }
    return resolved
}

def TypeChecker::check_block(&this, node: &AST, scope: &Scope) {
    let block = node.u.block
    block.scope = Scope::new(scope)
    let stmts = block.statements
    for let i = 0; i < stmts.size; i += 1 {
        let stmt = stmts.at(i) as &AST
        .check_statement(stmt, block.scope)
    }
}

def TypeChecker::resolve_scope_lookup(&this, node: &AST, scope: &Scope): &Symbol {
    match node.type {
        ASTType::NSLookup => {
            // FIXME: this is all sorts of hacky
            let lhs = .resolve_scope_lookup(node.u.lookup.lhs, scope)
            if not lhs? {
                .error(Error::new(node.u.lookup.lhs.span, "couldn't resolve scope lookup lhs"))
                return null
            }

            if lhs.type != SymbolType::Namespace {
                .error(Error::new(node.u.lookup.lhs.span, "needs to be a namespace to lookup"))
                return null
            }
            let ns = lhs.u.ns

            let name = node.u.lookup.rhs_name
            let res = ns.find_importable_symbol(name)
            node.resolved_symbol = res
            return res
        }
        ASTType::Identifier => {
            let name = node.u.ident.name
            let res = scope.lookup_recursive(name)
            node.resolved_symbol = res
            return res
        }
        else => {
            .error(Error::new(node.span, "Invalid scope lookup node"))
            return null
        }
    }
}

def TypeChecker::check_call(&this, node: &AST, scope: &Scope): &Type {
    // fixme: so much to check... args, existing function, etc...
    let callee = node.u.call.callee
    let args = node.u.call.args

    // FIXME: we want to be able to call `resolve_scope_lookup` here, but we can't because
    // we also want to be able to do something like `foo.bar()` etc where the LHS is not a scope lookup
    let res = .check_expression(callee, scope)
    if res? and res.base == BaseType::Function {
        let func = res.u.func
        let params = func.params

        if func.params.size < args.size {
            .error(Error::new(node.span, `Too many arguments, expected {func.params.size} but got {args.size}`))
        }

        for let i = 0; i < params.size; i += 1 {
            let param = params.at(i) as &Variable
            // Normal case
            if i < args.size {
                let arg = args.at(i) as &Argument
                let arg_type = .check_expression(arg.expr, scope)
                if arg_type? and not arg_type.eq(param.type) {
                    .error(Error::new(arg.expr.span, `Argument {i} has type {arg_type.str()} but expected {param.type.str()}`))
                }

            // Default argument case
            } else if param.default_value? {

                // FIXME: We should not be evaluating the default argument here during every call, 
                // we should be evaluating it at the time of checking the function declaration and using
                // a cached value here
                let new_arg = Argument::new(label: null, expr: param.default_value)
                // Add the default argument to the list of arguments
                args.push(new_arg)
            } else {
                .error(Error::new(node.span, `Missing required argument {param.name}`))
            }
        }

        if func.orig? {
            node.u.call.is_function_pointer = false
            node.u.call.func = func.orig
        }

        return func.return_type
    } else {
        .error(Error::new(callee.span, "Cannot call this expression"))
        return .error_type
    }
}

def TypeChecker::check_expression(&this, node: &AST, scope: &Scope): &Type {
    match node.type {
        ASTType::IntLiteral => {
            println(`int literal with value {node.u.num_literal.text}`)
            return .get_base_type(BaseType::I32, node.span)
        }
        ASTType::Identifier | ASTType::NSLookup => {
            let item = .resolve_scope_lookup(node, scope)
            if not item? {
                .error(Error::new(node.span, "Couldn't resolve this expression"))
                return .error_type
            }

            match item.type {
                Function => return item.u.func.type
                Variable => return item.u.var.type
                Namespace => {
                    .error(Error::new(node.span, "Cannot use a namespace as an expression"))
                    return .error_type
                }
                TypeDef => {
                    // Fixme: How will this work with struct constructors?
                    .error(Error::new(node.span, "Cannot use a type name as an expression"))
                    return .error_type
                }
            }
        }
        ASTType::Call => return .check_call(node, scope)
        else => {
            .error(Error::new(node.span, "Invalid expression lol"))
            return .error_type
        }
    }
}

def TypeChecker::check_statement(&this, node: &AST, scope: &Scope) {
    match node.type {
        ASTType::Return => {
            // todo: make sure in function
            // todo: empty return
            // todo: actually check return type
            let res = .check_expression(node.u.unary, scope)
            if res? {
                println(`return statement with type {res.str()}`)
            }
        }
        else => .check_expression(node, scope)
    }
}

def TypeChecker::check_function(&this, ns: &Namespace, func: &Function) {
    // todo: check params, return type
    let new_scope = Scope::new(ns.scope)

    let params = func.params
    for let i = 0; i < params.size; i += 1 {
        let param = params.at(i) as &Variable

        let default_expr = param.default_value
        if default_expr? {
            let default_type = .check_expression(default_expr, ns.scope)
            if not default_type? {
                .error(Error::new(default_expr.span, "Couldn't resolve default argument expression"))
            } else if not default_type.eq(param.type) {
                .error(Error::new(default_expr.span, `Default argument has type {default_type.str()} but expected {param.type.str()}`))
            }
        }
        
        new_scope.items.insert(param.name, Symbol::from_variable(param))
    }

    func.prefix = ns.prefix
    .check_block(func.body, new_scope)
}

def TypeChecker::check_namespace(&this, ns: &Namespace) {
    let imports = ns.imports
    for let i = 0; i < imports.size; i += 1 {
        let import = imports.at(i) as &AST
        .handle_import_statement(import, ns, ns.scope)
    }

    let functions = ns.functions;
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .check_function(ns, func)
    }

    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        // check if exists
        let name = iter.key()
        .check_namespace(iter.value())
    }
}

// Insert all the imported items defined in the Import AST statement, (relative to the current namespace),
// into the current scope.
def TypeChecker::handle_import_statement(&this, node: &AST, ns: &Namespace, scope: &Scope) {
    let path = node.u.import_path

    let base = .program.global
    if path.is_relative {
        base = ns
        for let i = 0; i < path.parent_count; i += 1 {
            if not base.parent? {
                // This should never happen, because the parser is responsible for handling this
                .error(Error::new(node.span, "Internal error: Could not typecheck import statement"))
                return
            }
            base = base.parent
        }
    }

    for let i = 0; i < path.parts.size-1; i += 1 {
        let part = path.parts.at(i) as &ImportPart
        let name = part.name
        let new_ns = base.namespaces.get(name)
        println(`?? finding symbol {name} in namespace {base.prefix}`)
        if not new_ns? {
            .error(Error::new(part.span, `Invalid import, namespace {name} does not exist`))
            return
        }
        base = new_ns
    }

    let last_part = path.parts.back() as &ImportPart
    let name = last_part.name
    println(`?? finding symbol {name} in namespace {base.prefix}`)
    let sym = base.find_importable_symbol(name)
    if not sym? {
        .error(Error::new(node.span, `Couldn't find importable symbol {name}`))
        return
    }
    println(`imported symbol {name} with type {sym.type} into namespace {ns.prefix}`)
    scope.items.insert(name, sym)

}

////// Pre-checking namespace for declarations //////

def TypeChecker::pre_check_function(&this, ns: &Namespace, func: &Function) {
    let item = Symbol::from_function(func.name, func)
    ns.scope.items.insert(func.name, item)

    func.return_type = .resolve_type(func.return_type, ns.scope)
    let params = func.params
    for let i = 0; i < params.size; i += 1 {
        let param = params.at(i) as &Variable
        param.type = .resolve_type(param.type, ns.scope)
    }

    // A function keeps track of a type that represents an equivalent function pointer type
    // This is used for type checking function calls
    let typ = Type::new_resolved(Function, func.span)
    typ.u.func = FunctionType::from_func(func)
    func.type = typ
}

def TypeChecker::pre_check_namespace(&this, ns: &Namespace) {
    let functions = ns.functions;
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .pre_check_function(ns, func)
    }
    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        let child = iter.value() as &Namespace
        let name = iter.key()

        if child.is_user_defined {
            ns.scope.items.insert(name, Symbol::from_namespace(name, child))
        }
        .pre_check_namespace(iter.value())
    }
}

////// Top-level call program //////

def TypeChecker::check(&this) {
    let global_ns = .program.global
    .pre_check_namespace(global_ns)
    .check_namespace(global_ns)
}
