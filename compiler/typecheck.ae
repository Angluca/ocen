use "compiler/ast.ae"
use "compiler/utils.ae"
use "lib/map.ae"

struct TypeChecker {
    cur_func: &Function
    program: &Program
    base_types_cache: [&Type; BaseType::NUM_BASE_TYPES as i32]
}

def TypeChecker::error(&this, err: &Error) {
    .program.errors.push(err)
}

def TypeChecker::new(program: &Program): &TypeChecker {
    let checker = calloc(1, sizeof(TypeChecker)) as &TypeChecker
    checker.program = program
    for let i = 0; i < BaseType::NUM_BASE_TYPES as i32; i += 1 {
        checker.base_types_cache[i] = Type::new(i as BaseType, Span::default())
    }
    return checker
}

def TypeChecker::get_type(&this, base: BaseType): &Type {
    return .base_types_cache[base as i32]
}

def TypeChecker::type_is_valid(&this, type: &Type): bool {
    if not type? return false

    match type.base {
        Pointer => return .type_is_valid(type.ptr)
        Function => {
            for let i = 0; i < type.func.params.size; i += 1 {
                let var = type.func.params.at(i) as &Variable
                if not .type_is_valid(var.type) {
                    return false
                }
            }
            return .type_is_valid(type.func.return_type)
        }
        Unresolved | Error => return false
        else => return true
    }
}

def TypeChecker::pre_check_namespace_function(&this, ns: &Namespace, func: &Function) {
    // todo: check if exists, check types
    let item = Symbol::from_function(func.name, func)
    ns.scope.items.insert(func.name, item)
    println(`inserted function {ns.prefix}{func.name} into scope`)

    // fixme: verify these types, get cached versions with methods eventually
    let func_type = Type::new(Function, func.span)
    func_type.func = FunctionType::new()
    func_type.func.orig = func
    func_type.func.return_type = func.return_type
    func_type.func.params = func.params
    func.type = func_type
}

def TypeChecker::pre_check_namespace(&this, ns: &Namespace) {
    let functions = ns.functions;
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .pre_check_namespace_function(ns, func)
    }
    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        println(`recursing on namespace {iter.key()}`)
        .pre_check_namespace(iter.value())
    }
}

def TypeChecker::check_block(&this, node: &AST, scope: &Scope) {
    let block = node.u.block
    block.scope = Scope::new(scope)
    let stmts = block.statements
    for let i = 0; i < stmts.size; i += 1 {
        let stmt = stmts.at(i) as &AST
        .check_statement(stmt, block.scope)
    }
}

def TypeChecker::resolve_scope_lookup(&this, node: &AST, scope: &Scope): &Symbol {
    match node.type {
        ASTType::ScopeLookup => {
            let lhs = .resolve_scope_lookup(node.u.lookup.lhs, scope)
            if not lhs? {
                .error(Error::new(node.u.lookup.lhs.span, "couldn't resolve scope lookup lhs"))
                return null
            }

            if lhs.type != SymbolType::Namespace {
                .error(Error::new(node.u.lookup.lhs.span, "needs to be a namespace to lookup"))
                return null
            }

            let rhs = node.u.lookup.rhs
            if rhs.type != ASTType::Identifier {
                .error(Error::new(rhs.span, "Needs to be an identifier..."))
                return null
            }

            let ns_scope = lhs.u.ns.scope
            let name = rhs.u.ident.name
            let res = ns_scope.lookup_recursive(name)
            node.u.lookup.resolved_symbol = res
            return res
        }
        ASTType::Identifier => {
            let name = node.u.ident.name
            return scope.lookup_recursive(name)
        }
        else => {
            .error(Error::new(node.span, "Invalid scope lookup node"))
            return null
        }
    }
}

def TypeChecker::check_expression(&this, node: &AST, scope: &Scope): &Type {
    match node.type {
        ASTType::IntLiteral => {
            println(`int literal with value {node.u.num_literal.text}`)
            return .get_type(BaseType::I32)
        }
        ASTType::Identifier | ASTType::ScopeLookup => {
            let item = .resolve_scope_lookup(node, scope)
            return null
        }
        ASTType::Call => {
            // fixme: so much to check... args, existing function, etc...
            let callee = node.u.call.callee
            let item = .resolve_scope_lookup(callee, scope)
            if item? {
                println(`call to {item.name}!!`)
                if item.type == SymbolType::Function {
                    println(`got a function {item.name}!!`)
                    node.u.call.is_function_pointer = false
                    node.u.call.func = item.u.func
                } else {
                    // check if function pointer (var of type function)
                    .error(Error::new(callee.span, "Not a function"))
                }
            } else {
                .error(Error::new(callee.span, "Unknown function"))
            }
            return null
        }
        else => {
            .error(Error::new(node.span, "Invalid expression lol"))
            return null
        }
    }
}

def TypeChecker::check_statement(&this, node: &AST, scope: &Scope) {
    match node.type {
        ASTType::Return => {
            // todo: make sure in function
            // todo: empty return
            // todo: actually check return type
            let res = .check_expression(node.u.unary, scope)
            if res? {
                println(`return statement with type {res.str()}`)
            }
        }
        else => {
            .error(Error::new(node.span, "Invalid statement lol"))
            return
        }
    }
}

def TypeChecker::check_namespace_function(&this, ns: &Namespace, func: &Function) {
    // todo: check params, return type
    // todo: new scope for func args
    func.prefix = ns.prefix
    .check_block(func.body, ns.scope)
}

def TypeChecker::check_namespace(&this, ns: &Namespace) {
    let functions = ns.functions;
    for let i = 0; i < functions.size; i += 1 {
        let func = functions.at(i) as &Function
        .check_namespace_function(ns, func)
    }
    let children = ns.namespaces
    for let iter = children.iter(); iter.cur?; iter.next() {
        // check if exists
        let name = iter.key()
        // TODO: actually check the imports for the module and only add those ones to the ns
        let item = Symbol::from_namespace(name, iter.value())
        ns.scope.items.insert(name, item)
        .check_namespace(iter.value())
    }
}

def TypeChecker::check(&this) {
    let global_ns = .program.global
    .pre_check_namespace(global_ns)
    .check_namespace(global_ns)
}
